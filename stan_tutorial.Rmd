---
title: "Введение в RStan: Оценка параметров"
author: "Марина Дубова"
output:
  html_document:
    df_print: paged
---

```{r}
library(rstan)
library(ggmcmc) # для классных диагностических графичков
```

## Генерация данных

Нормальное распределение со средним, которое необходимо оценить, и стандартным отклонением 15

```{r}
set.seed(100)

N <- 500
true_mu <- 90
test_scores <- rnorm(N, true_mu, 15)
data_1 <- list(N = length(test_scores), X = test_scores) # формат данных для stan - список с переменными
```

## Модель 1 

Необходимо оценить только среднее нормально распределенных данных

```{r}
model_1 <-
'
data {
  int<lower = 0> N;  // размер выборки (больше 0)
  vector[N] X; // наблюдения - вектор длины N
}

parameters {
  real<lower = 0> mu; // среднее нормального распределения, которое необходимо оценить
}

model {
  mu ~ normal(100, 25); // априорное распределение среднего
  X ~ normal(mu, 15); // функция правдоподобия
}
'
```

Типы переменных в stan: real, int, vector, row_vector, matrix, etc

Виды распределений в stan: normal, uniform, binomial, beta, cauchy, etc

## Генерация апостериорного распределения


```{r}
fit_1 <- stan(model_code = model_1, data = data_1, chains = 1, iter = 5000, warmup = 1000) # ! нужно всегда использовать несколько цепей для диагностики результата
```

## Диагностика!!!

? Rhat == 1

? n_eff > 1000

Если нет - нужно увеличить количество итераций (iter) при генерации апостериорного распределения

```{r}
print(fit_1)
```

Результат - байесовский доверительный интервал для параметра

```{r}
posterior_mu <- ggs(fit_1) # считываем сэмплы в удобном для ggmcmc формате
ggmcmc(D = posterior_mu, file = NULL, plot = 'ggs_histogram') # апостериорное распределение параметра
mean(posterior_mu$value > 90) # какую часть апостериорного распределения составляют средние больше 90?
```

```{r}
ggmcmc(D = posterior_mu, file = NULL, plot = 'ggs_traceplot') # должен выглядить как белый шум, все цепи варьируют вокруг одинаковых значений. Если нет - можно попробовать увеличить warmup

ggmcmc(D = posterior_mu, file = NULL, plot = 'ggs_compare_partial') # полное и частичное апостериорное распределение в идеале должны полностью перекрывать друг друга 

ggmcmc(D = posterior_mu, file = NULL, plot = 'ggs_autocorrelation') # в идеале: все значения после 1 на нуле или очень близки к нулю
```

Проверка с несколькими цепями

Анализ чувствительности к априорному распределению: проверка получения того же результата с использованием разных априорных распределений. В противном случае, необходимо доказать необходимость использования конкретного выбранного априорного распределения.

## Модель 2

Необходимо оценить и среднее, и стандартное отклонение

```{r}
model_2 <-
'
data {
  int<lower = 0> N;  // sample size
  vector[N] X;
}

parameters {
  real<lower = 0> mu;
  real<lower = 0> sigma;
}

model {
  mu ~ normal(100, 25);
  sigma ~ cauchy(0,15);
  X ~ normal(mu, sigma);
}
'
```

```{r}
fit_2 <- stan(model_code = model_2, data = data_1, chains = 1, iter = 5000, warmup = 1000)
```

```{r}
print(fit_2)
```

```{r}
posterior_fit_2 <- ggs(fit_2)
mean(posterior_fit_2$value > 90 & posterior_fit_2$Parameter == "mu")/mean(posterior_fit_2$Parameter == "mu")

ggmcmc(D = posterior_fit_2, file = NULL, plot = 'ggs_histogram')
ggmcmc(D = posterior_fit_2, file = NULL, plot = 'ggs_traceplot') 
ggmcmc(D = posterior_fit_2, file = NULL, plot = 'ggs_compare_partial') 
ggmcmc(D = posterior_fit_2, file = NULL, plot = 'ggs_autocorrelation')
```